"""
漏洞修复智能体 (Vulnerability Remediation Agent)
负责识别和修复系统漏洞，加固安全防护
"""

import os
import httpx
import json
import asyncio
import logging
import websockets.client
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from pathlib import Path
from dotenv import load_dotenv
from typing import List, Dict, Any, Optional

from fastmcp import FastMCP
from langchain_deepseek import ChatDeepSeek
from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain_core.prompts import ChatPromptTemplate
from langchain.tools import tool

# --- 设置日志 ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("vulnerability-agent")

# --- 后端WebSocket连接 ---
BACKEND_WS_URL = "ws://localhost:8080/ws/logs"
backend_ws = None

async def connect_to_backend():
    """连接到后端WebSocket"""
    global backend_ws
    try:
        if backend_ws:
            try:
                await backend_ws.close()
            except Exception:
                pass
            backend_ws = None
            
        backend_ws = await websockets.client.connect(BACKEND_WS_URL)
        
        await backend_ws.send(json.dumps({
            "level": "info",
            "source": "漏洞修复智能体",
            "message": "WebSocket连接已建立"
        }))
        
        logger.info(f"已连接到后端WebSocket: {BACKEND_WS_URL}")
        return True
    except Exception as e:
        logger.error(f"连接后端WebSocket失败: {e}")
        return False

async def send_log_to_backend(level: str, source: str, message: str, defense_info: dict = None):
    """发送防御日志到后端WebSocket"""
    global backend_ws
    
    log_data = {
        "timestamp": asyncio.get_event_loop().time(),
        "level": level,
        "source": source,
        "message": message,
        "defense_info": defense_info or {}
    }
    
    try:
        if backend_ws is None:
            await connect_to_backend()
        
        try:
            if backend_ws:
                await backend_ws.send(json.dumps(log_data, ensure_ascii=False))
                logger.debug(f"已发送防御日志到后端: {message}")
        except Exception as e:
            logger.warning(f"发送消息失败，尝试重新连接: {e}")
            await connect_to_backend()
            
            try:
                if backend_ws:
                    await backend_ws.send(json.dumps(log_data, ensure_ascii=False))
            except Exception:
                pass
    except Exception as e:
        logger.error(f"发送日志到后端WebSocket失败: {e}")

# --- 环境变量和配置 ---
dotenv_path = Path(__file__).parent / '.env'
load_dotenv(dotenv_path=dotenv_path)

VULNERABILITY_SERVICE_URL = os.getenv("VULNERABILITY_SERVICE_URL", "http://127.0.0.1:8009/mcp/")

# --- 初始化LLM和工具 ---
api_key = os.getenv("DEEPSEEK_API_KEY")
if not api_key:
    logger.warning("DEEPSEEK_API_KEY未设置，使用默认密钥")
    api_key = "sk-default-key"

try:
    llm = ChatDeepSeek(model="deepseek-chat", api_key=api_key)
    logger.info("ChatDeepSeek初始化成功")
except Exception as e:
    logger.error(f"ChatDeepSeek初始化失败: {e}")
    # 使用一个简单的模拟LLM
    llm = None

# 使用FastMCP客户端连接到漏洞修复服务
try:
    vulnerability_service = FastMCP.as_proxy(VULNERABILITY_SERVICE_URL)
    logger.info(f"FastMCP代理连接成功: {VULNERABILITY_SERVICE_URL}")
except Exception as e:
    logger.error(f"FastMCP代理连接失败: {e}")
    vulnerability_service = None

# --- 为Agent定义工具 ---
@tool
async def scan_system_vulnerabilities(target_system: str, scan_type: str = "comprehensive") -> str:
    """扫描系统漏洞"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", f"开始扫描系统漏洞: {target_system}")
        
        async with vulnerability_service.client as client:
            response = await client.call_tool(
                "scan_system_vulnerabilities",
                arguments={'target_system': target_system, 'scan_type': scan_type}
            )
        result = "\n".join([b.text for b in response.content if hasattr(b, "text")])
        
        # 解析结果并发送详细日志
        try:
            scan_data = json.loads(result)
            total_vulns = scan_data.get("total_vulnerabilities", 0)
            if total_vulns > 0:
                await send_log_to_backend("warning", "漏洞修复智能体", 
                                        f"发现 {total_vulns} 个漏洞，准备制定修复计划")
            else:
                await send_log_to_backend("info", "漏洞修复智能体", "漏洞扫描完成，系统安全状态良好")
        except:
            pass
        
        return result
    except Exception as e:
        await send_log_to_backend("error", "漏洞修复智能体", f"漏洞扫描失败: {e}")
        return f"执行漏洞扫描时出错: {e}"

@tool
async def apply_security_patch(system: str, patch_id: str, reboot_required: bool = False) -> str:
    """应用安全补丁"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", f"正在为系统 {system} 应用补丁 {patch_id}")
        
        async with vulnerability_service.client as client:
            response = await client.call_tool(
                "apply_security_patch",
                arguments={'system': system, 'patch_id': patch_id, 'reboot_required': reboot_required}
            )
        result = "\n".join([b.text for b in response.content if hasattr(b, "text")])
        
        await send_log_to_backend("success", "漏洞修复智能体", f"成功为系统 {system} 应用补丁 {patch_id}")
        return result
    except Exception as e:
        await send_log_to_backend("error", "漏洞修复智能体", f"补丁应用失败: {e}")
        return f"执行补丁应用时出错: {e}"

@tool
async def harden_system_configuration(system: str, hardening_profile: str = "standard") -> str:
    """系统安全加固"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", f"正在对系统 {system} 进行安全加固")
        
        async with vulnerability_service.client as client:
            response = await client.call_tool(
                "harden_system_configuration",
                arguments={'system': system, 'hardening_profile': hardening_profile}
            )
        result = "\n".join([b.text for b in response.content if hasattr(b, "text")])
        
        await send_log_to_backend("success", "漏洞修复智能体", f"成功完成系统 {system} 的安全加固")
        return result
    except Exception as e:
        await send_log_to_backend("error", "漏洞修复智能体", f"系统加固失败: {e}")
        return f"执行系统加固时出错: {e}"

@tool
async def update_antivirus_signatures() -> str:
    """更新防病毒特征库"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", "正在更新防病毒特征库")
        
        async with vulnerability_service.client as client:
            response = await client.call_tool(
                "update_antivirus_signatures",
                arguments={}
            )
        result = "\n".join([b.text for b in response.content if hasattr(b, "text")])
        
        await send_log_to_backend("success", "漏洞修复智能体", "防病毒特征库更新完成")
        return result
    except Exception as e:
        await send_log_to_backend("error", "漏洞修复智能体", f"特征库更新失败: {e}")
        return f"执行特征库更新时出错: {e}"

@tool
async def deploy_security_controls(control_type: str, target_systems: str = "all") -> str:
    """部署额外的安全控制措施"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", f"正在部署安全控制: {control_type}")
        
        async with vulnerability_service.client as client:
            response = await client.call_tool(
                "deploy_security_controls",
                arguments={'control_type': control_type, 'target_systems': target_systems}
            )
        result = "\n".join([b.text for b in response.content if hasattr(b, "text")])
        
        await send_log_to_backend("success", "漏洞修复智能体", f"成功部署安全控制: {control_type}")
        return result
    except Exception as e:
        await send_log_to_backend("error", "漏洞修复智能体", f"安全控制部署失败: {e}")
        return f"执行安全控制部署时出错: {e}"

@tool
async def generate_compliance_report(compliance_framework: str = "iso27001") -> str:
    """生成合规性报告"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", f"正在生成合规性报告: {compliance_framework}")
        
        async with vulnerability_service.client as client:
            response = await client.call_tool(
                "generate_compliance_report",
                arguments={'compliance_framework': compliance_framework}
            )
        result = "\n".join([b.text for b in response.content if hasattr(b, "text")])
        
        await send_log_to_backend("info", "漏洞修复智能体", "合规性报告生成完成")
        return result
    except Exception as e:
        await send_log_to_backend("error", "漏洞修复智能体", f"合规性报告生成失败: {e}")
        return f"执行合规性报告生成时出错: {e}"

# 工具列表
tools = [
    scan_system_vulnerabilities,
    apply_security_patch,
    harden_system_configuration,
    update_antivirus_signatures,
    deploy_security_controls,
    generate_compliance_report
]

# --- 定义Agent ---
prompt = ChatPromptTemplate.from_messages([
    ("system", """你是一个专业的漏洞修复智能体，负责识别和修复系统漏洞，加固安全防护。

你的主要职责：
1. **漏洞扫描**: 定期扫描系统漏洞，识别安全风险
2. **补丁管理**: 及时应用安全补丁，修复已知漏洞
3. **系统加固**: 配置安全策略，提高系统安全性
4. **合规管理**: 确保系统符合安全合规要求

工作流程：
1. 首先使用 scan_system_vulnerabilities 扫描目标系统漏洞
2. 分析漏洞严重程度和影响范围
3. 制定修复计划：
   - 对高危漏洞使用 apply_security_patch 立即修复
   - 使用 harden_system_configuration 加固系统配置
   - 使用 update_antivirus_signatures 更新防护特征
   - 使用 deploy_security_controls 部署额外安全控制
4. 使用 generate_compliance_report 生成合规报告

修复原则：
- 优先修复高危和关键漏洞
- 考虑业务连续性，合理安排维护窗口
- 测试补丁兼容性，避免业务中断
- 建立完整的修复记录和文档

请根据系统扫描结果，制定并执行相应的漏洞修复和系统加固策略。"""),
    ("human", "{input}"),
    ("placeholder", "{agent_scratchpad}")
])

# 创建Agent
try:
    if llm is not None:
        agent = create_tool_calling_agent(llm, tools, prompt)
        agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)
        logger.info("漏洞修复智能体创建成功")
    else:
        agent_executor = None
        logger.warning("LLM未初始化，智能体功能受限")
except Exception as e:
    logger.error(f"智能体创建失败: {e}")
    agent_executor = None

# --- FastAPI应用 ---
app = FastAPI(
    title="漏洞修复智能体",
    description="负责识别和修复系统漏洞，加固安全防护"
)

class VulnerabilityRequest(BaseModel):
    target_systems: str = Field(description="目标系统")
    scan_type: str = Field(default="comprehensive", description="扫描类型")
    auto_patch: bool = Field(default=False, description="是否自动应用补丁")
    hardening_profile: str = Field(default="standard", description="加固配置级别")

@app.post("/execute_vulnerability_remediation")
async def execute_vulnerability_remediation(request: VulnerabilityRequest):
    """执行漏洞修复任务"""
    try:
        await send_log_to_backend("info", "漏洞修复智能体", 
                                f"收到漏洞修复任务: {request.target_systems}")
        
        # 构建输入
        input_text = f"""
        目标系统: {request.target_systems}
        扫描类型: {request.scan_type}
        自动补丁: {'是' if request.auto_patch else '否'}
        加固级别: {request.hardening_profile}
        
        请执行以下任务：
        1. 扫描目标系统的安全漏洞
        2. 分析漏洞严重程度和修复优先级
        3. 制定详细的修复计划
        4. 根据配置执行补丁应用和系统加固
        5. 更新安全防护措施
        6. 生成修复报告和合规评估
        
        如果启用自动补丁，请对高危漏洞立即执行修复操作。
        """
        
        # 执行Agent
        if agent_executor is not None:
            result = await agent_executor.ainvoke({"input": input_text})
        else:
            # 如果智能体未初始化，返回模拟结果
            result = {
                "output": "漏洞修复智能体当前处于模拟模式，请配置DEEPSEEK_API_KEY以启用完整功能。"
            }
        
        await send_log_to_backend("success", "漏洞修复智能体", "漏洞修复任务执行完成")
        
        return {
            "status": "success",
            "message": "漏洞修复任务执行完成",
            "result": result["output"],
            "target_systems": request.target_systems
        }
        
    except Exception as e:
        error_msg = f"漏洞修复任务执行失败: {e}"
        logger.error(error_msg)
        await send_log_to_backend("error", "漏洞修复智能体", error_msg)
        raise HTTPException(status_code=500, detail=error_msg)

@app.get("/status")
async def get_status():
    """获取智能体状态"""
    return {
        "agent": "漏洞修复智能体",
        "status": "active",
        "service_url": VULNERABILITY_SERVICE_URL,
        "capabilities": [
            "系统漏洞扫描",
            "安全补丁应用",
            "系统安全加固",
            "防病毒更新",
            "安全控制部署",
            "合规性报告"
        ]
    }

# --- 主执行 ---
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8012)